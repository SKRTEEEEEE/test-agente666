# NATS JetStream - Reporte de Investigaci√≥n

## üìã Resumen Ejecutivo

NATS JetStream es una capa de persistencia y streaming construida sobre NATS (Neural Autonomic Transport System), un sistema de mensajer√≠a de alto rendimiento. Proporciona funcionalidades avanzadas de mensajer√≠a con garant√≠as de entrega, persistencia de mensajes, y capacidades de reproducci√≥n (replay).

## üéØ ¬øQu√© es NATS JetStream?

JetStream a√±ade las siguientes capacidades a NATS:
- **Persistencia**: Los mensajes se almacenan en disco/memoria
- **Entrega garantizada**: At-least-once, exactly-once delivery
- **Replay de mensajes**: Capacidad de reproducir mensajes hist√≥ricos
- **Stream processing**: Procesamiento de flujos de datos
- **Consumer groups**: M√∫ltiples consumidores con balanceo de carga
- **Message deduplication**: Eliminaci√≥n de duplicados
- **Horizontal scaling**: Escalabilidad mediante clustering

## üîç Comparaci√≥n: Sistema Actual vs. NATS JetStream

### Sistema Actual (queue-go con memoria)
```
Caracter√≠sticas:
‚úÖ Simple y ligero
‚úÖ Baja latencia
‚ùå Sin persistencia (se pierden datos al reiniciar)
‚ùå Sin garant√≠as de entrega
‚ùå Limitado a un solo nodo
‚ùå Sin replay de mensajes
‚ùå Gesti√≥n manual de estados
```

### Con NATS JetStream
```
Caracter√≠sticas:
‚úÖ Persistencia de mensajes
‚úÖ Garant√≠as de entrega (at-least-once, exactly-once)
‚úÖ Clustering y alta disponibilidad
‚úÖ Replay de mensajes hist√≥ricos
‚úÖ Consumer groups nativos
‚úÖ Monitoreo y observabilidad integrados
‚úÖ Escalabilidad horizontal
‚úÖ Deduplicaci√≥n autom√°tica de mensajes
```

## üí° Mejoras que Aporta NATS JetStream

### 1. **Persistencia y Durabilidad**
- Los mensajes sobreviven a reinicios del sistema
- Configuraci√≥n de retenci√≥n por tama√±o, tiempo o pol√≠tica
- Backup y disaster recovery

### 2. **Garant√≠as de Entrega**
- **At-least-once**: Garantiza que el mensaje se entrega al menos una vez
- **Exactly-once**: Evita duplicados mediante deduplicaci√≥n
- ACKs autom√°ticos y manuales

### 3. **Escalabilidad**
- Clustering nativo de NATS
- Distribuci√≥n de carga autom√°tica
- Failover autom√°tico

### 4. **Replay y Auditor√≠a**
- Reproducci√≥n de eventos hist√≥ricos
- Debugging de flujos de trabajo
- Auditor√≠a completa de tareas

### 5. **Consumer Groups**
- M√∫ltiples workers procesando en paralelo
- Balanceo de carga autom√°tico
- Tolerancia a fallos

### 6. **Monitoreo**
- M√©tricas integradas
- Estado del stream en tiempo real
- Observabilidad de consumers

## üèóÔ∏è Arquitectura Propuesta

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Docker Compose                          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                               ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îÇ
‚îÇ  ‚îÇ   app-go     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   queue-go   ‚îÇ                  ‚îÇ
‚îÇ  ‚îÇ  (Producer)  ‚îÇ         ‚îÇ  (API + Web) ‚îÇ                  ‚îÇ
‚îÇ  ‚îÇ  :8080       ‚îÇ         ‚îÇ    :8081     ‚îÇ                  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îÇ
‚îÇ                                    ‚îÇ                         ‚îÇ
‚îÇ                                    ‚ñº                         ‚îÇ
‚îÇ                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ                          ‚îÇ  NATS JetStream ‚îÇ                ‚îÇ
‚îÇ                          ‚îÇ   (Message Bus) ‚îÇ                ‚îÇ
‚îÇ                          ‚îÇ      :4222      ‚îÇ                ‚îÇ
‚îÇ                          ‚îÇ  Monitoring:8222‚îÇ                ‚îÇ
‚îÇ                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ                                   ‚îÇ                          ‚îÇ
‚îÇ                                   ‚ñº                          ‚îÇ
‚îÇ                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                ‚îÇ
‚îÇ                          ‚îÇ queue-worker-go ‚îÇ                ‚îÇ
‚îÇ                          ‚îÇ   (Consumer)    ‚îÇ                ‚îÇ
‚îÇ                          ‚îÇ  Processes tasks‚îÇ                ‚îÇ
‚îÇ                          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ
‚îÇ                                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Flujo de Trabajo

1. **Publicaci√≥n de Tareas**:
   - `app-go` o API REST publica tareas en JetStream
   - Stream: `TASKS` con subjects: `tasks.new`, `tasks.update`

2. **Procesamiento**:
   - `queue-worker-go` consume tareas del stream
   - Procesa la tarea y actualiza el estado
   - ACK autom√°tico al completar

3. **API REST** (queue-go):
   - Interface HTTP para gesti√≥n manual
   - Consulta estado de streams y consumers
   - Operaciones CRUD sobre tareas

## üìù Pasos para Implementar NATS JetStream

### Paso 1: Agregar NATS Server al Docker Compose

```yaml
services:
  nats:
    image: nats:latest
    container_name: agent666-nats
    ports:
      - "4222:4222"  # Client connections
      - "8222:8222"  # HTTP monitoring
      - "6222:6222"  # Cluster routing
    command: 
      - "--jetstream"
      - "--store_dir=/data"
      - "--max_memory_store=1GB"
      - "--max_file_store=10GB"
    volumes:
      - nats-data:/data
    networks:
      - agent666-network
    restart: unless-stopped

volumes:
  nats-data:
```

### Paso 2: Crear Cliente NATS en Go

**Dependencias**:
```go
go get github.com/nats-io/nats.go
```

**Estructura del Proyecto**:
```
queue-go/
‚îú‚îÄ‚îÄ nats/
‚îÇ   ‚îú‚îÄ‚îÄ client.go       # Cliente NATS y conexi√≥n
‚îÇ   ‚îú‚îÄ‚îÄ streams.go      # Definici√≥n de streams
‚îÇ   ‚îú‚îÄ‚îÄ publisher.go    # Publicaci√≥n de mensajes
‚îÇ   ‚îî‚îÄ‚îÄ consumer.go     # Consumo de mensajes
‚îú‚îÄ‚îÄ handlers.go         # Adaptadores HTTP -> NATS
‚îú‚îÄ‚îÄ main.go
‚îî‚îÄ‚îÄ ...
```

### Paso 3: Definir Streams y Subjects

```go
// Stream para tareas
Stream: TASKS
Subjects: 
  - tasks.new          # Nueva tarea
  - tasks.status.*     # Actualizaciones de estado (tasks.status.pending, etc.)
  - tasks.delete       # Eliminaci√≥n de tarea

// Consumer groups
Consumer: task-workers
  - Durable: true
  - AckPolicy: Explicit
  - MaxDeliver: 3
  - DeliverPolicy: New
```

### Paso 4: Implementar Publisher (API REST)

```go
// queue-go/handlers.go
func CreateTaskHandler(w http.ResponseWriter, r *http.Request) {
    // 1. Validar request
    // 2. Crear task
    // 3. Publicar en NATS: subject "tasks.new"
    // 4. Retornar respuesta HTTP
}
```

### Paso 5: Implementar Worker/Consumer

Crear nuevo servicio `queue-worker-go`:
```go
// queue-worker-go/main.go
func main() {
    // 1. Conectar a NATS
    // 2. Suscribirse a "tasks.new"
    // 3. Procesar mensajes
    // 4. ACK mensajes procesados
}
```

### Paso 6: Migrar Endpoints REST

- `POST /api/tasks` ‚Üí Publica en `tasks.new`
- `PATCH /api/tasks/{id}/status` ‚Üí Publica en `tasks.status.{status}`
- `DELETE /api/tasks/{id}` ‚Üí Publica en `tasks.delete`
- `GET /api/tasks` ‚Üí Consulta metadata del stream
- `GET /api/queue/status` ‚Üí Consulta estado del consumer

### Paso 7: Testing

**Unit Tests**:
- Publicaci√≥n de mensajes
- Consumo de mensajes
- Manejo de errores y reintentos

**Integration Tests**:
- Flujo completo: Publicar ‚Üí Consumir ‚Üí ACK
- Persistencia tras reinicio
- Consumer groups

**API Tests**:
- Endpoints REST con NATS en background

### Paso 8: Monitoreo

Acceder a `http://localhost:8222` para:
- Estado de streams
- Consumers activos
- Mensajes pendientes
- Estad√≠sticas de rendimiento

## üîß Configuraciones Recomendadas

### Stream Configuration
```go
&nats.StreamConfig{
    Name:        "TASKS",
    Subjects:    []string{"tasks.*", "tasks.status.*"},
    Retention:   nats.WorkQueuePolicy,  // Elimina mensajes al ser ACKed
    MaxAge:      7 * 24 * time.Hour,    // Retenci√≥n m√°xima 7 d√≠as
    Storage:     nats.FileStorage,       // Persistencia en disco
    Replicas:    1,                      // Aumentar en producci√≥n
}
```

### Consumer Configuration
```go
&nats.ConsumerConfig{
    Durable:       "task-workers",
    AckPolicy:     nats.AckExplicitPolicy,
    MaxDeliver:    3,                    // M√°ximo 3 intentos
    AckWait:       30 * time.Second,     // Timeout para ACK
    DeliverPolicy: nats.DeliverNewPolicy,
}
```

## üìä Casos de Uso Mejorados

### 1. **Tolerancia a Fallos**
- Worker crashea ‚Üí Mensaje vuelve a la cola autom√°ticamente
- NATS crashea ‚Üí Mensajes persisten en disco

### 2. **Escalado Horizontal**
- Ejecutar m√∫ltiples workers
- Balanceo de carga autom√°tico

### 3. **Debugging y Auditor√≠a**
- Reproducir tareas hist√≥ricas
- Ver estado completo del pipeline
- Identificar cuellos de botella

### 4. **Priorizaci√≥n de Tareas**
- Streams separados por prioridad
- Consumers dedicados por tipo de tarea

## ‚ö†Ô∏è Consideraciones

### Ventajas
- ‚úÖ Sistema robusto y probado en producci√≥n
- ‚úÖ Alto rendimiento (millones de msg/s)
- ‚úÖ F√°cil de operar
- ‚úÖ Excelente documentaci√≥n
- ‚úÖ Cliente Go oficial bien mantenido

### Desventajas
- ‚ö†Ô∏è Complejidad adicional vs. soluci√≥n en memoria
- ‚ö†Ô∏è Requiere infraestructura adicional (contenedor NATS)
- ‚ö†Ô∏è Curva de aprendizaje inicial
- ‚ö†Ô∏è Overhead m√≠nimo de latencia por persistencia

## üéì Recursos de Aprendizaje

- [NATS Documentation](https://docs.nats.io/)
- [JetStream Guide](https://docs.nats.io/nats-concepts/jetstream)
- [nats.go Client](https://github.com/nats-io/nats.go)
- [JetStream Examples](https://github.com/nats-io/nats.go/tree/main/examples/jetstream)

## üöÄ Pr√≥ximos Pasos Recomendados

1. ‚úÖ **Fase 1 - MVP**: Implementar JetStream b√°sico con un worker
2. üìà **Fase 2 - Escalado**: M√∫ltiples workers y consumer groups
3. üîÑ **Fase 3 - Avanzado**: Clustering de NATS para HA
4. üìä **Fase 4 - Observabilidad**: Integraci√≥n con Prometheus/Grafana

## üí≠ Conclusi√≥n

NATS JetStream es una soluci√≥n ideal para convertir el sistema de colas en memoria en un sistema distribuido, escalable y tolerante a fallos. Las mejoras en confiabilidad, persistencia y capacidades de procesamiento justifican la complejidad adicional para un sistema de producci√≥n.

Para el proyecto Agent666, permitir√°:
- **Persistencia de tareas** entre reinicios
- **Procesamiento distribuido** con m√∫ltiples workers
- **Auditor√≠a completa** del pipeline de tareas
- **Escalabilidad** para manejar cargas mayores
